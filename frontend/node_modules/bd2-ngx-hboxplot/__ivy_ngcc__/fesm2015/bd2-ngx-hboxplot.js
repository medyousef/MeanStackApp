import { EventEmitter, Component, ChangeDetectionStrategy, NgZone, ChangeDetectorRef, ElementRef, Input, Output, NgModule } from '@angular/core';
import * as d3lib from 'd3';

import * as ɵngcc0 from '@angular/core';
const d3 = d3lib;
/**
 D3 integration was originally based on the code for npm library: d3-ng2-service
 by Tom Wanzek, https://github.com/tomwanzek/d3-ng2-service.

 That package was used during developement and then converted into inline service
 to reduce the dependencies and boundle size.

 At some point, I moved to to simpler dependency on d3:
 npm install --save d3
 npm install --save-dev @types/d3

 and removed the parts from d3-modules.ts as they were causing errors
 (not sure how to fix them and also one dependency is easier to maintain).
 */

/*
// that has been removed after importing a single d3 dependency

export {
  // d3-array
  Bin,
  Bisector,
  HistogramGenerator,
  Numeric,
  ThresholdArrayGenerator,
  ThresholdCountGenerator,
  // d3-axis
  Axis,
  AxisContainerElement,
  AxisScale,
  AxisTimeInterval,
  // d3-scale
  InterpolatorFactory,
  ScaleBand,
  ScaleIdentity,
  ScaleLinear,
  ScaleLogarithmic,
  ScaleOrdinal,
  ScalePoint,
  ScalePower,
  ScaleQuantile,
  ScaleQuantize,
  ScaleSequential,
  ScaleThreshold,
  ScaleTime,

  // d3-selection
  ArrayLike,
  BaseEvent,
  BaseType,
  ContainerElement,
  EnterElement,
  Local,
  NamespaceLocalObject,
  NamespaceMap,
  Selection,
  SelectionFn,
  TransitionLike,
  ValueFn,
  // d3-selection-multi
  ValueMap,
  // d3-shape
  Arc,
  Area,
  DefaultArcObject,
  Line,
  Pie,
  PieArcDatum,
  RadialArea,
  RadialLine,
  Series,
  SeriesPoint,
  Stack,
  Symbol,
  SymbolType,
  // d3-transition
  Transition
} from './d3-modules';


 */

class LookAndFeel {
    constructor() {
        this.vMargin = 25;
        this.hMarginL = 20;
        this.hMarginR = 15;
        this.rowWidth = 30;
        this.rowGap = 0.2;
        this.transitionTime = 600;
        this.boxStrokeWidth = '2px';
        this.boxFillOpacity = 0.35;
        this.meanStrokeWidth = '4px';
        this.labelFont = '12px';
        this.labelFillOpacity = 0.35;
        this.backLabelOpacity = 0.30;
        this.backdropColor = 'white';
        this.backdropOpacity = 1;
        this.whiskerStrokeWidth = '1px';
        this.outliersStrokeWidth = '1px';
        this.outliersCircleRadius = 3;
        this.outliersFillOpacity = 0.4;
    }
}
let defualtLookAndFeel = function () {
    return new LookAndFeel();
};
class GraphicContext {
    constructor() {
        /*transitionTime: number;
      
         get transitionOn(): boolean {
         return (this.transitionTime && this.transitionTime > 0);
         };*/
        this.labelsTimers = [];
    }
}
function offsetScaleValue(x, pixOffset, scale) {
    const r = scale.range();
    const pos = scale(x) + pixOffset;
    if (pos < r[0]) {
        return r[0];
    }
    else if (pos > r[1]) {
        return r[1];
    }
    return pos;
}

class BoxDefinition {
    constructor() {
        this.outliers = [];
    }
}

class BoxUtil {
    dataToBoxes(data) {
        if (!data) {
            return [];
        }
        return data.map((v, ix) => {
            const b = this.datumToBox(v);
            b.ix = ix;
            b.key = (ix + 1) + '.';
            return b;
        });
    }
    datumToBox(data) {
        const box = new BoxDefinition();
        if (!data || data.length === 0) {
            return box;
        }
        data = data.sort(d3.ascending);
        box.mean = d3.mean(data);
        box.median = d3.median(data);
        box.fstQnt = d3.quantile(data, 0.25);
        box.thrdQnt = d3.quantile(data, 0.75);
        const iqr = 1.5 * (box.thrdQnt - box.fstQnt);
        box.lowWskr = box.fstQnt - iqr;
        box.highWskr = box.thrdQnt + iqr;
        for (let i = 0; i < data.length; i++) {
            if (data[i] >= box.lowWskr) {
                box.lowWskr = data[i];
                break;
            }
        }
        for (let i = data.length - 1; i >= 0; i--) {
            if (data[i] <= box.highWskr) {
                box.highWskr = data[i];
                break;
            }
        }
        box.outliers = data.filter(v => (v < box.lowWskr || v > box.highWskr));
        return box;
    }
    mockEmptyValues(boxes, missingVal) {
        boxes.forEach(box => {
            if (box.mean === undefined || box.mean === null) {
                box.mean = missingVal;
                box.median = missingVal;
                box.fstQnt = missingVal;
                box.thrdQnt = missingVal;
                box.lowWskr = missingVal;
                box.highWskr = missingVal;
            }
        });
    }
}

class BD2ColorPalette {
    static extendPalette(palette, size) {
        if (!palette || palette.length === 0) {
            palette = ['black'];
        }
        const out = [];
        for (let i = 0; i < size; i++) {
            out.push(palette[i % palette.length]);
        }
        return out;
    }
    static palette(size) {
        // if (true) return BD2ColorPalette.extendPalette(['#1f77b4'], size);
        if (size <= BD2ColorPalette.schemeCategory10.length) {
            return BD2ColorPalette.extendPalette(BD2ColorPalette.schemeCategory10, size);
        }
        else {
            return BD2ColorPalette.extendPalette(BD2ColorPalette.schemeCategory20, size);
        }
    }
}
BD2ColorPalette.schemeCategory10 = [
    '#1f77b4',
    '#ff7f0e',
    '#2ca02c',
    '#d62728',
    '#9467bd',
    '#8c564b',
    '#e377c2',
    '#7f7f7f',
    '#bcbd22',
    '#17becf'
];
BD2ColorPalette.schemeCategory20 = [
    '#1f77b4',
    '#aec7e8',
    '#ff7f0e',
    '#ffbb78',
    '#2ca02c',
    '#98df8a',
    '#d62728',
    '#ff9896',
    '#9467bd',
    '#c5b0d5',
    '#8c564b',
    '#c49c94',
    '#e377c2',
    '#f7b6d2',
    '#7f7f7f',
    '#c7c7c7',
    '#bcbd22',
    '#dbdb8d',
    '#17becf',
    '#9edae5'
];

class SmartRounder {
    static round(value, base) {
        base = base || value;
        base = Math.abs(base);
        if (base < 0.01) {
            return value;
        }
        if (base < 1) {
            return Math.round(value * 10000) / 10000;
        }
        if (base < 1000) {
            return Math.round(value * 100) / 100;
        }
        return Math.round(value);
    }
}

class HBoxPlotComponent {
    constructor(ngZone, changeDetectorRef, element) {
        this.ngZone = ngZone;
        this.changeDetectorRef = changeDetectorRef;
        /**
         * Necessary to control hiding of the element, otherwise the BBoxes are not defined and labels
         * were not rendered in correct places.
         *
         */
        this.hidden = false;
        this.removed = [];
        this.domain = [17, 36];
        this.palette = [];
        this.labels = [];
        this.labelsOn = 'always'; // trigger //null
        this.lookAndFeel = defualtLookAndFeel();
        this.sortChanged = false;
        this.colors = new EventEmitter();
        this.graphicContext = new GraphicContext();
        this.boxUtil = new BoxUtil();
        this.sortFunction = function (b1, b2) {
            return b1.ix - b2.ix;
        };
        this.d3 = d3;
        this.parentNativeElement = element.nativeElement;
    }
    set sorted(sorting) {
        if (sorting === 'median') {
            this.sortFunction = (b1, b2) => b1.median - b2.median;
        }
        else if (sorting === 'label') {
            // console.log("N",navigator.language);
            /*if (navigator.language) {
             this.sortFunction = (b1: BoxDefinition, b2: BoxDefinition) =>
             b1.label.localeCompare(b2.label, navigator.language, {sensitivity: 'case'});
             } else {
             this.sortFunction = (b1: BoxDefinition, b2: BoxDefinition) => b1.label.localeCompare(b2.label);
             };*/
            this.sortFunction = (b1, b2) => {
                if (b1.label === b2.label) {
                    return 0;
                }
                if (b1.label < b2.label) {
                    return -1;
                }
                return 1;
            };
        }
        else {
            this.sortFunction = (b1, b2) => b1.ix - b2.ix;
        }
    }
    /**
     * It is detached from angular to prevent unnecessary change detection
     */
    ngAfterViewInit() {
        this.changeDetectorRef.detach();
        // console.log("AFI");
    }
    /**
     * Explicit triggers re-drawing as need to have all the parameters set (so will not redrawn if data came frist and domain later)
     * @param changes
     */
    ngOnChanges(changes) {
        // console.log("Changes", changes);
        // otherwise the hidden on inner div was not updated
        this.changeDetectorRef.detectChanges();
        this.initSVG();
        // this.handleHiding();
        if (!this.data) {
            return;
        }
        this.sortChanged = changes.sorted !== undefined;
        if (!this.hidden) {
            this.updatePlot();
        }
    }
    isDataUpdate(changes) {
        return (changes.data || changes.removed || changes.domain || changes.palette || changes.labels);
    }
    initSVG() {
        if (!this.d3Svg) {
            const d3ParentElement = this.d3.select(this.parentNativeElement);
            this.d3Svg = d3ParentElement.select('.hbox-plot').append('svg');
            this.d3Svg.attr('width', '0');
        }
    }
    ngOnInit() {
        if (this.parentNativeElement !== null) {
        }
        else {
            console.error('Missing parrent element for the component');
        }
    }
    ngOnDestroy() {
        if (this.d3Svg && this.d3Svg.empty && !this.d3Svg.empty()) {
            this.d3Svg.selectAll('*').remove();
        }
    }
    /**
     * Only for testing
     * @param context
     */
    testGraphicContext(context) {
        this.graphicContext = context;
    }
    /* Not needed any more, the hidding is achieved by simple div hidden attribute
     // and the problem with labels background rendering is solved using delayed rendering with a timer.
     handleHiding() {
     if (this.hidden) {
     this.removed = this.d3Svg.remove();
     } else {
     if (this.removed) {
     this.d3.select(this.parentNativeElement)
     .select('.hbox-plot')
     .append(() => this.d3Svg.node());
     this.removed = undefined;
     }
     }
  
     }*/
    updatePlot() {
        // this.graphicContext.transitionTime = this.lookAndFeel.transitionTime;
        if (this.lookAndFeel.transitionTime > 0) {
            this.graphicContext.transitionOn = true;
            this.ngZone.runOutsideAngular(() => {
                this.graphicContext.transition = this.d3.transition().duration(this.lookAndFeel.transitionTime);
            });
        }
        else {
            this.graphicContext.transitionOn = false;
            this.graphicContext.transition = undefined;
        }
        this.graphicContext = this.updatePalette(this.data, this.palette, this.graphicContext);
        let boxes = this.prepareDataModel(this.data, this.removed, this.labels, this.graphicContext.palette, this.domain, this.sortFunction);
        boxes = boxes.filter(b => !b.hidden);
        this.graphicContext = this.preparePane(boxes, this.lookAndFeel, this.graphicContext);
        this.graphicContext = this.prepareScales(boxes, this.domain, this.lookAndFeel, this.graphicContext);
        this.graphicContext = this.plotAxisBox(boxes, this.domain, this.lookAndFeel, this.mainPane, this.graphicContext);
        this.graphicContext = this.plotDataBoxes(boxes, this.lookAndFeel, this.mainPane, this.graphicContext);
        this.graphicContext = this.prepareTooltip(this.mainPane, this.graphicContext);
        this.graphicContext = this.prepareLabels(boxes, this.mainPane, this.lookAndFeel, this.graphicContext, this.labelsOn);
    }
    prepareDataModel(data, removed, labels, palette, domain, sortFunction) {
        let boxes = this.boxUtil.dataToBoxes(data);
        this.boxUtil.mockEmptyValues(boxes, domain[1]);
        this.labelBoxes(boxes, labels);
        this.colorBoxes(boxes, palette);
        removed.forEach(ix => {
            if (boxes[ix]) {
                boxes[ix].hidden = true;
            }
        });
        boxes = boxes.sort(sortFunction);
        return boxes;
    }
    updatePalette(data, palette, graphicContext) {
        if (!palette || palette.length === 0) {
            graphicContext.palette = BD2ColorPalette.palette(data.length);
        }
        else {
            graphicContext.palette = BD2ColorPalette.extendPalette(palette, data.length);
        }
        this.colors.next(graphicContext.palette.slice());
        return graphicContext;
    }
    colorBoxes(boxes, palette) {
        boxes.forEach(b => b.color = palette[b.ix]);
    }
    preparePane(data, lookAndFeel, graphicContext) {
        // console.log("PP",data);
        if (!this.mainPane) {
            // let d3ParentElement = this.d3.select(this.parentNativeElement);
            // this.d3Svg = d3ParentElement.select('.hbox-plot').append<SVGSVGElement>('svg');
            this.d3Svg.attr('width', '100%');
            this.mainPane = this.d3Svg.append('g');
            this.mainPane.classed('mainPane', true);
        }
        const pWidth = 500;
        const pHeight = this.calculateWorkspaceHeight(data, lookAndFeel) + 2 * lookAndFeel.vMargin;
        const elm = (graphicContext.transitionOn ? this.d3Svg.transition(graphicContext.transition) : this.d3Svg);
        elm.attr('viewBox', '0 0 ' + pWidth + ' ' + pHeight);
        this.mainPane.attr('transform', 'translate(' + lookAndFeel.hMarginL + ',' + lookAndFeel.vMargin + ')');
        // .attr('transform', 'translate(' + (pWidth / 2) + ',' + (pHeight / 2) + ')'); //moves 0,0 of the pain to the middle of the graphics
        graphicContext.workspaceWidth = pWidth - lookAndFeel.hMarginL - lookAndFeel.hMarginR;
        graphicContext.workspaceHeight = pHeight - 2 * lookAndFeel.vMargin;
        return graphicContext;
    }
    calculateWorkspaceHeight(data, lookAndFeel) {
        return lookAndFeel.rowWidth * data.length;
    }
    labelBoxes(boxes, labels) {
        if (!labels) {
            labels = [];
        }
        boxes.forEach((b, ix) => {
            b.label = labels[ix] ? labels[ix] : '' + (ix + 1);
        });
    }
    prepareLabels(boxes, mainPane, lookAndFeel, graphicContext, labelsOn) {
        if (!graphicContext.labelsWrapper) {
            graphicContext.labelsWrapper = mainPane.append('g')
                .classed('labelsWrapper', true);
        }
        if (!graphicContext.backLabelsWrapper) {
            graphicContext.backLabelsWrapper = mainPane.insert('g', 'g.dataWrapper')
                .classed('backLabelsWrapper', true);
        }
        const backLabelsOn = labelsOn === 'always';
        const mainLabelsOn = labelsOn === 'always' || labelsOn === 'trigger';
        const labels = graphicContext.labelsWrapper.selectAll('g.yLabel')
            .data(mainLabelsOn ? boxes : [], (d) => d.key);
        labels.exit().remove();
        const newLabels = labels.enter()
            .append('g')
            .classed('yLabel', true);
        this.ngZone.runOutsideAngular(() => {
            newLabels.on('mouseover', function (evnt, d) {
                d3.select(this)
                    .selectAll('.yLabel')
                    // .style("visibility", "visible");
                    .style('display', null);
            }).on('mouseout', function () {
                d3.select(this)
                    .selectAll('.yLabel')
                    // .style("visibility", "hidden");
                    .style('display', 'none');
            });
        });
        newLabels.append('rect')
            .attr('class', 'yTrigger')
            .style('fill-opacity', 1);
        newLabels.append('rect')
            .attr('class', 'yLabel')
            .style('fill-opacity', 0.35)
            // .style("visibility", "hidden");
            .style('display', 'none');
        newLabels.append('text')
            .attr('class', 'yLabel')
            .attr('text-anchor', 'left')
            .attr('dominant-baseline', 'central')
            .style('font-size', lookAndFeel.labelFont)
            .style('opacity', 1)
            .attr('x', 5);
        const backLabels = graphicContext.backLabelsWrapper.selectAll('g.yLabel')
            .data(backLabelsOn ? boxes : [], (d) => d.key);
        backLabels.exit().remove();
        const newBackLabels = backLabels.enter()
            .append('g')
            .classed('yLabel', true);
        /*
         newBackLabels.append<SVGGElement>("rect")
         .attr("class", "yLabel")
         .style("fill-opacity", 0.05);
         */
        newBackLabels.append('text')
            .attr('class', 'yLabel')
            .attr('text-anchor', 'left')
            .attr('dominant-baseline', 'central')
            .style('font-size', lookAndFeel.labelFont)
            .style('opacity', lookAndFeel.backLabelOpacity)
            .attr('x', 5);
        // .style("visibility", "hidden");
        const enterUpdate = newLabels.merge(labels);
        const backEnterUpdate = newBackLabels.merge(backLabels);
        // called with delay to allow, parent divs to component sets their visibility, otherwise the bboxes cannot be calculated
        // and the labels backgrounds and trigers are not rendered correctly
        // it is a hack, but don't know how to do it correctly
        // timers have to be cleared as otherwise saw errors in logs for fast changing input data (like cause by sorting and pagination)
        graphicContext.labelsTimers.forEach(timer => clearTimeout(timer));
        graphicContext.labelsTimers = [];
        const timer = setTimeout(() => {
            const bboxes = [];
            enterUpdate.select('text')
                .style('display', null)
                .attr('y', d => graphicContext.yScale(d.key) + graphicContext.yScale.bandwidth() / 2)
                .text(d => d.label)
                .each(function (d) {
                bboxes.push(this.getBBox());
                // console.log("D: " + d.label, this.getBBox());
            })
                .style('display', 'none');
            let elm = backEnterUpdate.select('text');
            elm = (graphicContext.transitionOn ? elm.transition(graphicContext.transition) : elm);
            elm
                .attr('y', d => graphicContext.yScale(d.key) + graphicContext.yScale.bandwidth() / 2)
                .text(d => d.label);
            const trigers = enterUpdate.select('.yTrigger')
                .style('fill', d => d.color)
                .style('stroke', d => d.color);
            let telm = trigers.data(bboxes);
            telm = (graphicContext.transitionOn ? telm.transition(graphicContext.transition) : telm);
            telm
                .attr('x', -7)
                .attr('y', b => b.y - 3)
                .attr('width', b => 7)
                .attr('height', b => b.height + 6);
            const frames = enterUpdate.select('rect.yLabel')
                .style('fill', d => d.color)
                .style('fill-opacity', lookAndFeel.labelFillOpacity);
            frames.data(bboxes)
                .attr('x', 0)
                .attr('y', b => b.y - 3)
                .attr('width', b => b.width + 10)
                .attr('height', b => b.height + 7);
            /*
             let backFrames = backEnterUpdate.select<SVGSVGElement>("rect.yLabel")
             .style("fill", d => d.color);
      
             backFrames.data(bboxes)
             .attr("x", 0)
             .attr("y", b => b.y - 3)
             .attr("width", b => b.width + 10)
             .attr("height", b => b.height + 7);
             */
        }, 10);
        graphicContext.labelsTimers.push(timer);
        return graphicContext;
    }
    prepareTooltip(mainPane, graphicContext) {
        if (graphicContext.tooltipWrapper) {
            return graphicContext;
        }
        graphicContext.tooltipWrapper = mainPane.append('g')
            .classed('tooltipWrapper', true);
        graphicContext.tooltipBox = graphicContext.tooltipWrapper.append('rect')
            .style('fill', 'white')
            .style('fill-opacity', 0.8)
            .style('stroke', 'grey');
        graphicContext.tooltipText = graphicContext.tooltipWrapper.append('text')
            .attr('class', 'tooltip')
            // .attr("text-anchor", "left")
            .attr('text-anchor', 'middle')
            // .attr("alignment-baseline", "middle")
            // .attr("alignment-baseline", "baseline")
            // .attr("dy", "-10px")
            .style('opacity', 1);
        graphicContext.tooltipWrapper
            // .style("visibility", "hidden");
            .style('display', 'none');
        return graphicContext;
    }
    showTooltip(v, x, y) {
        // console.log("Show: " + v + ";" + this.constructor.name);
        // console.log('Show: ' + v + '; ' + x + ': ' + y);
        // console.log('v', SmartRounder.round(v));
        // console.log('x', this.graphicContext.xScale(x));
        // console.log('y', this.graphicContext.yScale(y));
        if (!this.graphicContext.tooltipText) {
            return;
        }
        this.graphicContext.tooltipText
            .attr('x', this.graphicContext.xScale(x))
            .attr('y', this.graphicContext.yScale(y))
            .text(SmartRounder.round(v));
        // I have to change the display here even before the box is ready as
        // in firefox the getBBox was not working if called with display none
        // giving NS_ERROR_FAILURE 2147500037
        this.graphicContext.tooltipWrapper
            // .style("visibility", "visible");
            .style('display', null);
        const bbox = this.graphicContext.tooltipText.node().getBBox();
        this.graphicContext.tooltipBox
            .attr('x', bbox.x - 3)
            .attr('y', bbox.y - 2)
            .attr('width', bbox.width + 6)
            .attr('height', bbox.height + 4);
    }
    hideTooltip() {
        // console.log("Hide: ");
        if (!this.graphicContext.tooltipText) {
            return;
        }
        this.graphicContext.tooltipWrapper
            // .style("visibility", "hidden");
            .style('display', 'none');
        // this.graphicContext.tooltipText
        // .transition().duration(this.lookAndFeel.baseTransitionsTime / 2)
        // .style("opacity", 0);
    }
    prepareScales(data, domain, lookAndFeel, graphicContext) {
        if (!graphicContext.xScale) {
            graphicContext.xScale = d3.scaleLinear()
                .clamp(true);
        }
        graphicContext.xScale
            .domain(domain)
            .range([0, graphicContext.workspaceWidth]);
        if (!graphicContext.yScale) {
            graphicContext.yScale = d3.scaleBand()
                .padding(lookAndFeel.rowGap);
        }
        const domainY = data.map((d) => d.key);
        graphicContext.yScale
            .domain(domainY)
            .range([0, graphicContext.workspaceHeight]);
        return graphicContext;
    }
    plotAxisBox(data, domain, lookAndFeel, mainPane, graphicContext) {
        if (!graphicContext.axisWrapper) {
            graphicContext.axisWrapper = this.initAxisWrapper(mainPane);
        }
        graphicContext = this.plotHorizontalScales(domain, lookAndFeel, graphicContext);
        graphicContext = this.plotVerticalScales(data, lookAndFeel, graphicContext);
        return graphicContext;
    }
    initAxisWrapper(mainPane) {
        let wrapper = mainPane.select('.axisWrapper');
        if (wrapper.size() === 0) {
            wrapper = mainPane.append('g').attr('class', 'axisWrapper');
            wrapper.append('g').attr('class', 'xTopAxis');
            wrapper.append('g').attr('class', 'xBottomAxis');
            wrapper.append('g').attr('class', 'yLeftAxis');
            wrapper.append('g').attr('class', 'yRightAxis');
        }
        return wrapper;
    }
    plotHorizontalScales(domain, lookAndFeel, graphicContext) {
        if (!graphicContext.xTopAxis) {
            graphicContext.xTopAxis = d3.axisTop(graphicContext.xScale);
        }
        if (!graphicContext.xBottomAxis) {
            graphicContext.xBottomAxis = d3.axisBottom(graphicContext.xScale);
        }
        graphicContext.axisWrapper
            .select('g.xTopAxis')
            .call(graphicContext.xTopAxis);
        let elm = graphicContext.axisWrapper.select('g.xBottomAxis');
        elm = (graphicContext.transitionOn ? elm.transition(graphicContext.transition) : elm);
        elm
            .attr('transform', 'translate(0,' + graphicContext.workspaceHeight + ')')
            .call(graphicContext.xBottomAxis);
        return graphicContext;
    }
    plotVerticalScales(data, lookAndFeel, graphicContext) {
        if (!graphicContext.yLeftAxis) {
            graphicContext.yLeftAxis = d3.axisLeft(graphicContext.yScale)
                .tickFormat(() => '');
        }
        if (!graphicContext.yRightAxis) {
            graphicContext.yRightAxis = d3.axisRight(graphicContext.yScale)
                .tickValues([]);
        }
        let elm = graphicContext.axisWrapper.select('g.yLeftAxis');
        elm = (graphicContext.transitionOn ? elm.transition(graphicContext.transition) : elm);
        elm
            .call(graphicContext.yLeftAxis);
        elm = graphicContext.axisWrapper.select('g.yRightAxis')
            .attr('transform', 'translate(' + graphicContext.workspaceWidth + ',0)');
        elm = (graphicContext.transitionOn ? elm.transition(graphicContext.transition) : elm);
        elm
            .call(graphicContext.yRightAxis);
        return graphicContext;
    }
    plotDataBoxes(boxes, lookAndFeel, mainPane, graphicContext) {
        if (!graphicContext.dataWrapper) {
            graphicContext.dataWrapper = mainPane.append('g').attr('class', 'dataWrapper');
        }
        let boxWidgets = graphicContext.dataWrapper.selectAll('.boxWidget');
        boxWidgets = boxWidgets.data(boxes, d => d.key);
        this.updateBoxWidgets(boxWidgets, lookAndFeel, graphicContext);
        const newBoxWidgets = boxWidgets.enter()
            .append('g').attr('class', 'boxWidget');
        this.createBoxWidgets(newBoxWidgets, lookAndFeel, graphicContext);
        boxWidgets.exit().remove();
        return graphicContext;
    }
    updateBoxWidgets(boxWidgets, lookAndFeel, graphicContext) {
        // this.ngZone.runOutsideAngular(() => {
        boxWidgets.select('rect.backdrop')
            .call(this.positionBackdrop, graphicContext);
        this.updateWhiskers(boxWidgets.select('g.whiskers'), graphicContext);
        boxWidgets.select('g.box rect')
            .call(this.positionBoxRectangle, graphicContext);
        boxWidgets.select('g.box line.medianline')
            .call(this.positionMedianLine, graphicContext);
        boxWidgets.select('g.box line.meanline')
            .call(this.positionMeanLine, graphicContext);
        const out = boxWidgets.select('g.outliers').selectAll('.outlier')
            .data(d => d.outliers.map(x => [x, d.key, d.color]));
        out.enter()
            .call(this.createOutlier, lookAndFeel, graphicContext, this.positionOutlier);
        out.call(this.positionOutlier, graphicContext);
        out.exit().remove();
        // });
    }
    positionBackdrop(elm, graphicContext) {
        elm = (graphicContext.transitionOn ? elm.transition(graphicContext.transition) : elm);
        elm
            .attr('x', (d) => offsetScaleValue(d.lowWskr, -5, graphicContext.xScale))
            .attr('y', (d) => {
            return graphicContext.yScale(d.key);
        })
            .attr('width', (d) => {
            const x1 = offsetScaleValue(d.lowWskr, -5, graphicContext.xScale);
            const x2 = offsetScaleValue(d.highWskr, +5, graphicContext.xScale);
            return x2 - x1;
        })
            .attr('height', (d) => {
            return graphicContext.yScale.bandwidth();
        });
    }
    positionBoxRectangle(elm, graphicContext) {
        elm = (graphicContext.transitionOn ? elm.transition(graphicContext.transition) : elm);
        elm
            .attr('x', (d) => graphicContext.xScale(d.fstQnt))
            .attr('y', (d) => {
            return graphicContext.yScale(d.key);
        })
            .attr('width', (d) => (graphicContext.xScale(d.thrdQnt) - graphicContext.xScale(d.fstQnt)))
            .attr('height', (d) => {
            return graphicContext.yScale.bandwidth();
        })
            .style('stroke', d => d.color)
            .style('fill', d => d.color);
    }
    positionMedianLine(elm, graphicContext) {
        elm = (graphicContext.transitionOn ? elm.transition(graphicContext.transition) : elm);
        elm
            .attr('x1', (d, i) => graphicContext.xScale(d.median))
            .attr('y1', (d, i) => graphicContext.yScale(d.key))
            .attr('x2', (d, i) => graphicContext.xScale(d.median))
            .attr('y2', (d, i) => graphicContext.yScale(d.key) + graphicContext.yScale.bandwidth())
            .style('stroke', d => d.color)
            // .style("visibility", d => d.mean === d.median ? "hidden" : "visible");
            .style('display', d => d.mean === d.median ? 'none' : null);
    }
    positionMeanLine(elm, graphicContext) {
        elm = (graphicContext.transitionOn ? elm.transition(graphicContext.transition) : elm);
        elm
            .attr('x1', (d, i) => graphicContext.xScale(d.mean))
            .attr('y1', (d, i) => graphicContext.yScale(d.key))
            .attr('x2', (d, i) => graphicContext.xScale(d.mean))
            .attr('y2', (d, i) => graphicContext.yScale(d.key) + graphicContext.yScale.bandwidth())
            .style('stroke', d => d.color);
    }
    positionOutlier(elm, graphicContext) {
        elm = (graphicContext.transitionOn ? elm.transition(graphicContext.transition) : elm);
        elm.attr('cx', d => graphicContext.xScale(d[0]))
            .attr('cy', d => graphicContext.yScale(d[1]) + graphicContext.yScale.bandwidth() / 2)
            .style('stroke', d => d[2])
            .style('fill', d => d[2]);
    }
    createOutlier(elm, lookAndFeel, graphicContext, positionOutlierFunction) {
        elm
            .append('circle')
            .attr('class', 'outlier')
            .attr('r', lookAndFeel.outliersCircleRadius)
            .style('stroke-width', lookAndFeel.outliersStrokeWidth)
            .style('fill-opacity', lookAndFeel.outliersFillOpacity)
            .call(positionOutlierFunction, graphicContext);
    }
    positionWhiskerLine(elm, left, graphicContext) {
        elm = (graphicContext.transitionOn ? elm.transition(graphicContext.transition) : elm);
        elm
            .attr('x1', (d, i) => left ? graphicContext.xScale(d.lowWskr) : graphicContext.xScale(d.thrdQnt))
            .attr('y1', (d, i) => graphicContext.yScale(d.key) + graphicContext.yScale.bandwidth() / 2)
            .attr('x2', (d, i) => left ? graphicContext.xScale(d.fstQnt) : graphicContext.xScale(d.highWskr))
            .attr('y2', (d, i) => graphicContext.yScale(d.key) + graphicContext.yScale.bandwidth() / 2)
            .style('stroke', d => d.color)
            // .style("visibility", d => (left && (d.lowWskr === d.fstQnt)) || (!left && (d.highWskr === d.thrdQnt)) ? "hidden" : "visible");
            .style('display', d => (left && (d.lowWskr === d.fstQnt)) || (!left && (d.highWskr === d.thrdQnt)) ? 'none' : null);
    }
    positionWhiskerTip(elm, left, graphicContext) {
        elm = (graphicContext.transitionOn ? elm.transition(graphicContext.transition) : elm);
        elm
            .attr('x1', (d, i) => left ? graphicContext.xScale(d.lowWskr) : graphicContext.xScale(d.highWskr))
            .attr('y1', (d, i) => graphicContext.yScale(d.key))
            .attr('x2', (d, i) => left ? graphicContext.xScale(d.lowWskr) : graphicContext.xScale(d.highWskr))
            .attr('y2', (d, i) => graphicContext.yScale(d.key) + graphicContext.yScale.bandwidth())
            .style('stroke', d => d.color)
            // .style("visibility", d => (left && (d.lowWskr === d.fstQnt)) || (!left && (d.highWskr === d.thrdQnt)) ? "hidden" : "visible");
            .style('display', d => (left && (d.lowWskr === d.fstQnt)) || (!left && (d.highWskr === d.thrdQnt)) ? 'none' : null);
    }
    updateWhiskers(whiskers, graphicContext) {
        whiskers.select('line.whiskerlineL')
            .call(this.positionWhiskerLine, true, graphicContext);
        whiskers.select('line.whiskerlineR')
            .call(this.positionWhiskerLine, false, graphicContext);
        whiskers.select('line.whiskertipL')
            .call(this.positionWhiskerTip, true, graphicContext);
        whiskers.select('line.whiskertipR')
            .call(this.positionWhiskerTip, false, graphicContext);
    }
    createWhiskers(whiskers, lookAndFeel, graphicContext) {
        const lwhiskr = whiskers.append('line')
            .attr('class', 'whiskerlineL')
            .style('stroke-width', lookAndFeel.whiskerStrokeWidth)
            .style('stroke-dasharray', '4 3')
            .call(this.positionWhiskerLine, true, graphicContext);
        const rwhiskr = whiskers.append('line')
            .attr('class', 'whiskerlineR')
            .style('stroke-width', lookAndFeel.whiskerStrokeWidth)
            .style('stroke-dasharray', '4 3')
            .call(this.positionWhiskerLine, false, graphicContext);
        const lTip = whiskers.append('line')
            .attr('class', 'whiskertipL')
            .style('stroke-width', lookAndFeel.whiskerStrokeWidth)
            .call(this.positionWhiskerTip, true, graphicContext);
        const rTip = whiskers.append('line')
            .attr('class', 'whiskertipR')
            .style('stroke-width', lookAndFeel.whiskerStrokeWidth)
            .call(this.positionWhiskerTip, false, graphicContext);
    }
    createBoxes(widgets, lookAndFeel, graphicContext) {
        const rect = widgets.append('rect')
            .attr('class', 'box')
            .style('stroke-width', lookAndFeel.boxStrokeWidth)
            .style('fill-opacity', lookAndFeel.boxFillOpacity)
            .call(this.positionBoxRectangle, graphicContext);
        const median = widgets.append('line')
            .attr('class', 'medianline')
            .style('stroke-width', lookAndFeel.boxStrokeWidth)
            .call(this.positionMedianLine, graphicContext);
        const instance = this;
        this.ngZone.runOutsideAngular(() => {
            rect.on('mouseover', function (evnt, d) {
                instance.showTooltip(d.median, d.median, d.key);
            })
                .on('mouseout', function () {
                instance.hideTooltip();
            });
            median.on('mouseover', function (evnt, d) {
                instance.showTooltip(d.median, d.median, d.key);
            })
                .on('mouseout', function () {
                instance.hideTooltip();
            });
        });
        const mean = widgets
            .append('line')
            .attr('class', 'meanline')
            .style('stroke-width', lookAndFeel.meanStrokeWidth)
            .style('stroke-dasharray', '4 2')
            .call(this.positionMeanLine, graphicContext);
        // has to be outside angular, to prevent detection
        this.ngZone.runOutsideAngular(() => {
            mean
                .on('mouseover', function (evnt, d) {
                instance.showTooltip(d.mean, d.mean, d.key);
            })
                .on('mouseout', function () {
                instance.hideTooltip();
            });
        });
    }
    createBoxWidgets(newBoxWidgets, lookAndFeel, graphicContext) {
        // this.ngZone.runOutsideAngular(() => {
        const instance = this;
        const backdrops = newBoxWidgets.append('rect').attr('class', 'backdrop')
            // .style("stroke-width", lookAndFeel.boxStrokeWidth)
            .style('fill-opacity', lookAndFeel.backdropOpacity)
            .style('fill', lookAndFeel.backdropColor)
            .call(this.positionBackdrop, graphicContext);
        const whiskers = newBoxWidgets.append('g').attr('class', 'whiskers');
        this.createWhiskers(whiskers, lookAndFeel, graphicContext);
        const boxes = newBoxWidgets.append('g').attr('class', 'box');
        this.createBoxes(boxes, lookAndFeel, graphicContext);
        const outliers = newBoxWidgets.append('g').attr('class', 'outliers');
        outliers.selectAll('.outlier')
            .data(d => d.outliers.map(x => [x, d.key, d.color]))
            .enter()
            .call(this.createOutlier, lookAndFeel, graphicContext, this.positionOutlier);
        // });
    }
}
HBoxPlotComponent.ɵfac = function HBoxPlotComponent_Factory(t) { return new (t || HBoxPlotComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
HBoxPlotComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: HBoxPlotComponent, selectors: [["bd2-ngx-hbox-plot"]], inputs: { hidden: "hidden", removed: "removed", domain: "domain", palette: "palette", labels: "labels", labelsOn: "labelsOn", lookAndFeel: "lookAndFeel", sorted: "sorted", data: "data" }, outputs: { colors: "colors" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], decls: 1, vars: 1, consts: [[1, "hbox-plot", 3, "hidden"]], template: function HBoxPlotComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelement(0, "div", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("hidden", ctx.hidden);
    } }, styles: ["[_nghost-%COMP%]     .axisWrapper path {\n        stroke: gray;\n      }\n\n      [_nghost-%COMP%]     .axisWrapper line {\n        stroke: gray;\n      }\n\n      [_nghost-%COMP%]     .axisWrapper text {\n        fill: gray;\n      }"], changeDetection: 0 });
HBoxPlotComponent.ctorParameters = () => [
    { type: NgZone },
    { type: ChangeDetectorRef },
    { type: ElementRef }
];
HBoxPlotComponent.propDecorators = {
    hidden: [{ type: Input }],
    data: [{ type: Input }],
    removed: [{ type: Input }],
    domain: [{ type: Input }],
    palette: [{ type: Input }],
    labels: [{ type: Input }],
    labelsOn: [{ type: Input }],
    lookAndFeel: [{ type: Input }],
    sorted: [{ type: Input }],
    colors: [{ type: Output }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(HBoxPlotComponent, [{
        type: Component,
        args: [{
                selector: 'bd2-ngx-hbox-plot',
                changeDetection: ChangeDetectionStrategy.OnPush,
                template: `
    <div class="hbox-plot" [hidden]="hidden"></div>
  `,
                styles: [`
      :host /deep/ .axisWrapper path {
        stroke: gray;
      }

      :host /deep/ .axisWrapper line {
        stroke: gray;
      }

      :host /deep/ .axisWrapper text {
        fill: gray;
      }
    `]
            }]
    }], function () { return [{ type: ɵngcc0.NgZone }, { type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.ElementRef }]; }, { hidden: [{
            type: Input
        }], removed: [{
            type: Input
        }], domain: [{
            type: Input
        }], palette: [{
            type: Input
        }], labels: [{
            type: Input
        }], labelsOn: [{
            type: Input
        }], lookAndFeel: [{
            type: Input
        }], colors: [{
            type: Output
        }], sorted: [{
            type: Input
        }], data: [{
            type: Input
        }] }); })();

class BD2NgxHBoxplotModule {
}
BD2NgxHBoxplotModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: BD2NgxHBoxplotModule });
BD2NgxHBoxplotModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function BD2NgxHBoxplotModule_Factory(t) { return new (t || BD2NgxHBoxplotModule)(); }, imports: [[]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(BD2NgxHBoxplotModule, { declarations: [HBoxPlotComponent], exports: [HBoxPlotComponent] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(BD2NgxHBoxplotModule, [{
        type: NgModule,
        args: [{
                declarations: [HBoxPlotComponent],
                imports: [],
                exports: [HBoxPlotComponent]
            }]
    }], null, null); })();

/*
 * Public API Surface of bd2-ngx-hboxplot
 */

/**
 * Generated bundle index. Do not edit.
 */

export { BD2NgxHBoxplotModule, HBoxPlotComponent };

//# sourceMappingURL=bd2-ngx-hboxplot.js.map