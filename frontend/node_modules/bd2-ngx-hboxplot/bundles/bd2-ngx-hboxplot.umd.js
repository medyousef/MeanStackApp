(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('d3')) :
  typeof define === 'function' && define.amd ? define('bd2-ngx-hboxplot', ['exports', '@angular/core', 'd3'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global['bd2-ngx-hboxplot'] = {}, global.ng.core, global.d3lib));
}(this, (function (exports, core, d3lib) { 'use strict';

  function _interopNamespace(e) {
    if (e && e.__esModule) { return e; } else {
      var n = Object.create(null);
      if (e) {
        Object.keys(e).forEach(function (k) {
          if (k !== 'default') {
            var d = Object.getOwnPropertyDescriptor(e, k);
            Object.defineProperty(n, k, d.get ? d : {
              enumerable: true,
              get: function () {
                return e[k];
              }
            });
          }
        });
      }
      n['default'] = e;
      return Object.freeze(n);
    }
  }

  var d3lib__namespace = /*#__PURE__*/_interopNamespace(d3lib);

  var d3 = d3lib__namespace;
  /**
   D3 integration was originally based on the code for npm library: d3-ng2-service
   by Tom Wanzek, https://github.com/tomwanzek/d3-ng2-service.

   That package was used during developement and then converted into inline service
   to reduce the dependencies and boundle size.

   At some point, I moved to to simpler dependency on d3:
   npm install --save d3
   npm install --save-dev @types/d3

   and removed the parts from d3-modules.ts as they were causing errors
   (not sure how to fix them and also one dependency is easier to maintain).
   */

  /*
  // that has been removed after importing a single d3 dependency

  export {
    // d3-array
    Bin,
    Bisector,
    HistogramGenerator,
    Numeric,
    ThresholdArrayGenerator,
    ThresholdCountGenerator,
    // d3-axis
    Axis,
    AxisContainerElement,
    AxisScale,
    AxisTimeInterval,
    // d3-scale
    InterpolatorFactory,
    ScaleBand,
    ScaleIdentity,
    ScaleLinear,
    ScaleLogarithmic,
    ScaleOrdinal,
    ScalePoint,
    ScalePower,
    ScaleQuantile,
    ScaleQuantize,
    ScaleSequential,
    ScaleThreshold,
    ScaleTime,

    // d3-selection
    ArrayLike,
    BaseEvent,
    BaseType,
    ContainerElement,
    EnterElement,
    Local,
    NamespaceLocalObject,
    NamespaceMap,
    Selection,
    SelectionFn,
    TransitionLike,
    ValueFn,
    // d3-selection-multi
    ValueMap,
    // d3-shape
    Arc,
    Area,
    DefaultArcObject,
    Line,
    Pie,
    PieArcDatum,
    RadialArea,
    RadialLine,
    Series,
    SeriesPoint,
    Stack,
    Symbol,
    SymbolType,
    // d3-transition
    Transition
  } from './d3-modules';


   */

  var LookAndFeel = /** @class */ (function () {
      function LookAndFeel() {
          this.vMargin = 25;
          this.hMarginL = 20;
          this.hMarginR = 15;
          this.rowWidth = 30;
          this.rowGap = 0.2;
          this.transitionTime = 600;
          this.boxStrokeWidth = '2px';
          this.boxFillOpacity = 0.35;
          this.meanStrokeWidth = '4px';
          this.labelFont = '12px';
          this.labelFillOpacity = 0.35;
          this.backLabelOpacity = 0.30;
          this.backdropColor = 'white';
          this.backdropOpacity = 1;
          this.whiskerStrokeWidth = '1px';
          this.outliersStrokeWidth = '1px';
          this.outliersCircleRadius = 3;
          this.outliersFillOpacity = 0.4;
      }
      return LookAndFeel;
  }());
  var defualtLookAndFeel = function () {
      return new LookAndFeel();
  };
  var GraphicContext = /** @class */ (function () {
      function GraphicContext() {
          /*transitionTime: number;
        
           get transitionOn(): boolean {
           return (this.transitionTime && this.transitionTime > 0);
           };*/
          this.labelsTimers = [];
      }
      return GraphicContext;
  }());
  function offsetScaleValue(x, pixOffset, scale) {
      var r = scale.range();
      var pos = scale(x) + pixOffset;
      if (pos < r[0]) {
          return r[0];
      }
      else if (pos > r[1]) {
          return r[1];
      }
      return pos;
  }

  var BoxDefinition = /** @class */ (function () {
      function BoxDefinition() {
          this.outliers = [];
      }
      return BoxDefinition;
  }());

  var BoxUtil = /** @class */ (function () {
      function BoxUtil() {
      }
      BoxUtil.prototype.dataToBoxes = function (data) {
          var _this = this;
          if (!data) {
              return [];
          }
          return data.map(function (v, ix) {
              var b = _this.datumToBox(v);
              b.ix = ix;
              b.key = (ix + 1) + '.';
              return b;
          });
      };
      BoxUtil.prototype.datumToBox = function (data) {
          var box = new BoxDefinition();
          if (!data || data.length === 0) {
              return box;
          }
          data = data.sort(d3.ascending);
          box.mean = d3.mean(data);
          box.median = d3.median(data);
          box.fstQnt = d3.quantile(data, 0.25);
          box.thrdQnt = d3.quantile(data, 0.75);
          var iqr = 1.5 * (box.thrdQnt - box.fstQnt);
          box.lowWskr = box.fstQnt - iqr;
          box.highWskr = box.thrdQnt + iqr;
          for (var i = 0; i < data.length; i++) {
              if (data[i] >= box.lowWskr) {
                  box.lowWskr = data[i];
                  break;
              }
          }
          for (var i = data.length - 1; i >= 0; i--) {
              if (data[i] <= box.highWskr) {
                  box.highWskr = data[i];
                  break;
              }
          }
          box.outliers = data.filter(function (v) { return (v < box.lowWskr || v > box.highWskr); });
          return box;
      };
      BoxUtil.prototype.mockEmptyValues = function (boxes, missingVal) {
          boxes.forEach(function (box) {
              if (box.mean === undefined || box.mean === null) {
                  box.mean = missingVal;
                  box.median = missingVal;
                  box.fstQnt = missingVal;
                  box.thrdQnt = missingVal;
                  box.lowWskr = missingVal;
                  box.highWskr = missingVal;
              }
          });
      };
      return BoxUtil;
  }());

  var BD2ColorPalette = /** @class */ (function () {
      function BD2ColorPalette() {
      }
      BD2ColorPalette.extendPalette = function (palette, size) {
          if (!palette || palette.length === 0) {
              palette = ['black'];
          }
          var out = [];
          for (var i = 0; i < size; i++) {
              out.push(palette[i % palette.length]);
          }
          return out;
      };
      BD2ColorPalette.palette = function (size) {
          // if (true) return BD2ColorPalette.extendPalette(['#1f77b4'], size);
          if (size <= BD2ColorPalette.schemeCategory10.length) {
              return BD2ColorPalette.extendPalette(BD2ColorPalette.schemeCategory10, size);
          }
          else {
              return BD2ColorPalette.extendPalette(BD2ColorPalette.schemeCategory20, size);
          }
      };
      return BD2ColorPalette;
  }());
  BD2ColorPalette.schemeCategory10 = [
      '#1f77b4',
      '#ff7f0e',
      '#2ca02c',
      '#d62728',
      '#9467bd',
      '#8c564b',
      '#e377c2',
      '#7f7f7f',
      '#bcbd22',
      '#17becf'
  ];
  BD2ColorPalette.schemeCategory20 = [
      '#1f77b4',
      '#aec7e8',
      '#ff7f0e',
      '#ffbb78',
      '#2ca02c',
      '#98df8a',
      '#d62728',
      '#ff9896',
      '#9467bd',
      '#c5b0d5',
      '#8c564b',
      '#c49c94',
      '#e377c2',
      '#f7b6d2',
      '#7f7f7f',
      '#c7c7c7',
      '#bcbd22',
      '#dbdb8d',
      '#17becf',
      '#9edae5'
  ];

  var SmartRounder = /** @class */ (function () {
      function SmartRounder() {
      }
      SmartRounder.round = function (value, base) {
          base = base || value;
          base = Math.abs(base);
          if (base < 0.01) {
              return value;
          }
          if (base < 1) {
              return Math.round(value * 10000) / 10000;
          }
          if (base < 1000) {
              return Math.round(value * 100) / 100;
          }
          return Math.round(value);
      };
      return SmartRounder;
  }());

  var HBoxPlotComponent = /** @class */ (function () {
      function HBoxPlotComponent(ngZone, changeDetectorRef, element) {
          this.ngZone = ngZone;
          this.changeDetectorRef = changeDetectorRef;
          /**
           * Necessary to control hiding of the element, otherwise the BBoxes are not defined and labels
           * were not rendered in correct places.
           *
           */
          this.hidden = false;
          this.removed = [];
          this.domain = [17, 36];
          this.palette = [];
          this.labels = [];
          this.labelsOn = 'always'; // trigger //null
          this.lookAndFeel = defualtLookAndFeel();
          this.sortChanged = false;
          this.colors = new core.EventEmitter();
          this.graphicContext = new GraphicContext();
          this.boxUtil = new BoxUtil();
          this.sortFunction = function (b1, b2) {
              return b1.ix - b2.ix;
          };
          this.d3 = d3;
          this.parentNativeElement = element.nativeElement;
      }
      Object.defineProperty(HBoxPlotComponent.prototype, "sorted", {
          set: function (sorting) {
              if (sorting === 'median') {
                  this.sortFunction = function (b1, b2) { return b1.median - b2.median; };
              }
              else if (sorting === 'label') {
                  // console.log("N",navigator.language);
                  /*if (navigator.language) {
                   this.sortFunction = (b1: BoxDefinition, b2: BoxDefinition) =>
                   b1.label.localeCompare(b2.label, navigator.language, {sensitivity: 'case'});
                   } else {
                   this.sortFunction = (b1: BoxDefinition, b2: BoxDefinition) => b1.label.localeCompare(b2.label);
                   };*/
                  this.sortFunction = function (b1, b2) {
                      if (b1.label === b2.label) {
                          return 0;
                      }
                      if (b1.label < b2.label) {
                          return -1;
                      }
                      return 1;
                  };
              }
              else {
                  this.sortFunction = function (b1, b2) { return b1.ix - b2.ix; };
              }
          },
          enumerable: false,
          configurable: true
      });
      /**
       * It is detached from angular to prevent unnecessary change detection
       */
      HBoxPlotComponent.prototype.ngAfterViewInit = function () {
          this.changeDetectorRef.detach();
          // console.log("AFI");
      };
      /**
       * Explicit triggers re-drawing as need to have all the parameters set (so will not redrawn if data came frist and domain later)
       * @param changes
       */
      HBoxPlotComponent.prototype.ngOnChanges = function (changes) {
          // console.log("Changes", changes);
          // otherwise the hidden on inner div was not updated
          this.changeDetectorRef.detectChanges();
          this.initSVG();
          // this.handleHiding();
          if (!this.data) {
              return;
          }
          this.sortChanged = changes.sorted !== undefined;
          if (!this.hidden) {
              this.updatePlot();
          }
      };
      HBoxPlotComponent.prototype.isDataUpdate = function (changes) {
          return (changes.data || changes.removed || changes.domain || changes.palette || changes.labels);
      };
      HBoxPlotComponent.prototype.initSVG = function () {
          if (!this.d3Svg) {
              var d3ParentElement = this.d3.select(this.parentNativeElement);
              this.d3Svg = d3ParentElement.select('.hbox-plot').append('svg');
              this.d3Svg.attr('width', '0');
          }
      };
      HBoxPlotComponent.prototype.ngOnInit = function () {
          if (this.parentNativeElement !== null) {
          }
          else {
              console.error('Missing parrent element for the component');
          }
      };
      HBoxPlotComponent.prototype.ngOnDestroy = function () {
          if (this.d3Svg && this.d3Svg.empty && !this.d3Svg.empty()) {
              this.d3Svg.selectAll('*').remove();
          }
      };
      /**
       * Only for testing
       * @param context
       */
      HBoxPlotComponent.prototype.testGraphicContext = function (context) {
          this.graphicContext = context;
      };
      /* Not needed any more, the hidding is achieved by simple div hidden attribute
       // and the problem with labels background rendering is solved using delayed rendering with a timer.
       handleHiding() {
       if (this.hidden) {
       this.removed = this.d3Svg.remove();
       } else {
       if (this.removed) {
       this.d3.select(this.parentNativeElement)
       .select('.hbox-plot')
       .append(() => this.d3Svg.node());
       this.removed = undefined;
       }
       }
    
       }*/
      HBoxPlotComponent.prototype.updatePlot = function () {
          var _this = this;
          // this.graphicContext.transitionTime = this.lookAndFeel.transitionTime;
          if (this.lookAndFeel.transitionTime > 0) {
              this.graphicContext.transitionOn = true;
              this.ngZone.runOutsideAngular(function () {
                  _this.graphicContext.transition = _this.d3.transition().duration(_this.lookAndFeel.transitionTime);
              });
          }
          else {
              this.graphicContext.transitionOn = false;
              this.graphicContext.transition = undefined;
          }
          this.graphicContext = this.updatePalette(this.data, this.palette, this.graphicContext);
          var boxes = this.prepareDataModel(this.data, this.removed, this.labels, this.graphicContext.palette, this.domain, this.sortFunction);
          boxes = boxes.filter(function (b) { return !b.hidden; });
          this.graphicContext = this.preparePane(boxes, this.lookAndFeel, this.graphicContext);
          this.graphicContext = this.prepareScales(boxes, this.domain, this.lookAndFeel, this.graphicContext);
          this.graphicContext = this.plotAxisBox(boxes, this.domain, this.lookAndFeel, this.mainPane, this.graphicContext);
          this.graphicContext = this.plotDataBoxes(boxes, this.lookAndFeel, this.mainPane, this.graphicContext);
          this.graphicContext = this.prepareTooltip(this.mainPane, this.graphicContext);
          this.graphicContext = this.prepareLabels(boxes, this.mainPane, this.lookAndFeel, this.graphicContext, this.labelsOn);
      };
      HBoxPlotComponent.prototype.prepareDataModel = function (data, removed, labels, palette, domain, sortFunction) {
          var boxes = this.boxUtil.dataToBoxes(data);
          this.boxUtil.mockEmptyValues(boxes, domain[1]);
          this.labelBoxes(boxes, labels);
          this.colorBoxes(boxes, palette);
          removed.forEach(function (ix) {
              if (boxes[ix]) {
                  boxes[ix].hidden = true;
              }
          });
          boxes = boxes.sort(sortFunction);
          return boxes;
      };
      HBoxPlotComponent.prototype.updatePalette = function (data, palette, graphicContext) {
          if (!palette || palette.length === 0) {
              graphicContext.palette = BD2ColorPalette.palette(data.length);
          }
          else {
              graphicContext.palette = BD2ColorPalette.extendPalette(palette, data.length);
          }
          this.colors.next(graphicContext.palette.slice());
          return graphicContext;
      };
      HBoxPlotComponent.prototype.colorBoxes = function (boxes, palette) {
          boxes.forEach(function (b) { return b.color = palette[b.ix]; });
      };
      HBoxPlotComponent.prototype.preparePane = function (data, lookAndFeel, graphicContext) {
          // console.log("PP",data);
          if (!this.mainPane) {
              // let d3ParentElement = this.d3.select(this.parentNativeElement);
              // this.d3Svg = d3ParentElement.select('.hbox-plot').append<SVGSVGElement>('svg');
              this.d3Svg.attr('width', '100%');
              this.mainPane = this.d3Svg.append('g');
              this.mainPane.classed('mainPane', true);
          }
          var pWidth = 500;
          var pHeight = this.calculateWorkspaceHeight(data, lookAndFeel) + 2 * lookAndFeel.vMargin;
          var elm = (graphicContext.transitionOn ? this.d3Svg.transition(graphicContext.transition) : this.d3Svg);
          elm.attr('viewBox', '0 0 ' + pWidth + ' ' + pHeight);
          this.mainPane.attr('transform', 'translate(' + lookAndFeel.hMarginL + ',' + lookAndFeel.vMargin + ')');
          // .attr('transform', 'translate(' + (pWidth / 2) + ',' + (pHeight / 2) + ')'); //moves 0,0 of the pain to the middle of the graphics
          graphicContext.workspaceWidth = pWidth - lookAndFeel.hMarginL - lookAndFeel.hMarginR;
          graphicContext.workspaceHeight = pHeight - 2 * lookAndFeel.vMargin;
          return graphicContext;
      };
      HBoxPlotComponent.prototype.calculateWorkspaceHeight = function (data, lookAndFeel) {
          return lookAndFeel.rowWidth * data.length;
      };
      HBoxPlotComponent.prototype.labelBoxes = function (boxes, labels) {
          if (!labels) {
              labels = [];
          }
          boxes.forEach(function (b, ix) {
              b.label = labels[ix] ? labels[ix] : '' + (ix + 1);
          });
      };
      HBoxPlotComponent.prototype.prepareLabels = function (boxes, mainPane, lookAndFeel, graphicContext, labelsOn) {
          if (!graphicContext.labelsWrapper) {
              graphicContext.labelsWrapper = mainPane.append('g')
                  .classed('labelsWrapper', true);
          }
          if (!graphicContext.backLabelsWrapper) {
              graphicContext.backLabelsWrapper = mainPane.insert('g', 'g.dataWrapper')
                  .classed('backLabelsWrapper', true);
          }
          var backLabelsOn = labelsOn === 'always';
          var mainLabelsOn = labelsOn === 'always' || labelsOn === 'trigger';
          var labels = graphicContext.labelsWrapper.selectAll('g.yLabel')
              .data(mainLabelsOn ? boxes : [], function (d) { return d.key; });
          labels.exit().remove();
          var newLabels = labels.enter()
              .append('g')
              .classed('yLabel', true);
          this.ngZone.runOutsideAngular(function () {
              newLabels.on('mouseover', function (evnt, d) {
                  d3.select(this)
                      .selectAll('.yLabel')
                      // .style("visibility", "visible");
                      .style('display', null);
              }).on('mouseout', function () {
                  d3.select(this)
                      .selectAll('.yLabel')
                      // .style("visibility", "hidden");
                      .style('display', 'none');
              });
          });
          newLabels.append('rect')
              .attr('class', 'yTrigger')
              .style('fill-opacity', 1);
          newLabels.append('rect')
              .attr('class', 'yLabel')
              .style('fill-opacity', 0.35)
              // .style("visibility", "hidden");
              .style('display', 'none');
          newLabels.append('text')
              .attr('class', 'yLabel')
              .attr('text-anchor', 'left')
              .attr('dominant-baseline', 'central')
              .style('font-size', lookAndFeel.labelFont)
              .style('opacity', 1)
              .attr('x', 5);
          var backLabels = graphicContext.backLabelsWrapper.selectAll('g.yLabel')
              .data(backLabelsOn ? boxes : [], function (d) { return d.key; });
          backLabels.exit().remove();
          var newBackLabels = backLabels.enter()
              .append('g')
              .classed('yLabel', true);
          /*
           newBackLabels.append<SVGGElement>("rect")
           .attr("class", "yLabel")
           .style("fill-opacity", 0.05);
           */
          newBackLabels.append('text')
              .attr('class', 'yLabel')
              .attr('text-anchor', 'left')
              .attr('dominant-baseline', 'central')
              .style('font-size', lookAndFeel.labelFont)
              .style('opacity', lookAndFeel.backLabelOpacity)
              .attr('x', 5);
          // .style("visibility", "hidden");
          var enterUpdate = newLabels.merge(labels);
          var backEnterUpdate = newBackLabels.merge(backLabels);
          // called with delay to allow, parent divs to component sets their visibility, otherwise the bboxes cannot be calculated
          // and the labels backgrounds and trigers are not rendered correctly
          // it is a hack, but don't know how to do it correctly
          // timers have to be cleared as otherwise saw errors in logs for fast changing input data (like cause by sorting and pagination)
          graphicContext.labelsTimers.forEach(function (timer) { return clearTimeout(timer); });
          graphicContext.labelsTimers = [];
          var timer = setTimeout(function () {
              var bboxes = [];
              enterUpdate.select('text')
                  .style('display', null)
                  .attr('y', function (d) { return graphicContext.yScale(d.key) + graphicContext.yScale.bandwidth() / 2; })
                  .text(function (d) { return d.label; })
                  .each(function (d) {
                  bboxes.push(this.getBBox());
                  // console.log("D: " + d.label, this.getBBox());
              })
                  .style('display', 'none');
              var elm = backEnterUpdate.select('text');
              elm = (graphicContext.transitionOn ? elm.transition(graphicContext.transition) : elm);
              elm
                  .attr('y', function (d) { return graphicContext.yScale(d.key) + graphicContext.yScale.bandwidth() / 2; })
                  .text(function (d) { return d.label; });
              var trigers = enterUpdate.select('.yTrigger')
                  .style('fill', function (d) { return d.color; })
                  .style('stroke', function (d) { return d.color; });
              var telm = trigers.data(bboxes);
              telm = (graphicContext.transitionOn ? telm.transition(graphicContext.transition) : telm);
              telm
                  .attr('x', -7)
                  .attr('y', function (b) { return b.y - 3; })
                  .attr('width', function (b) { return 7; })
                  .attr('height', function (b) { return b.height + 6; });
              var frames = enterUpdate.select('rect.yLabel')
                  .style('fill', function (d) { return d.color; })
                  .style('fill-opacity', lookAndFeel.labelFillOpacity);
              frames.data(bboxes)
                  .attr('x', 0)
                  .attr('y', function (b) { return b.y - 3; })
                  .attr('width', function (b) { return b.width + 10; })
                  .attr('height', function (b) { return b.height + 7; });
              /*
               let backFrames = backEnterUpdate.select<SVGSVGElement>("rect.yLabel")
               .style("fill", d => d.color);
        
               backFrames.data(bboxes)
               .attr("x", 0)
               .attr("y", b => b.y - 3)
               .attr("width", b => b.width + 10)
               .attr("height", b => b.height + 7);
               */
          }, 10);
          graphicContext.labelsTimers.push(timer);
          return graphicContext;
      };
      HBoxPlotComponent.prototype.prepareTooltip = function (mainPane, graphicContext) {
          if (graphicContext.tooltipWrapper) {
              return graphicContext;
          }
          graphicContext.tooltipWrapper = mainPane.append('g')
              .classed('tooltipWrapper', true);
          graphicContext.tooltipBox = graphicContext.tooltipWrapper.append('rect')
              .style('fill', 'white')
              .style('fill-opacity', 0.8)
              .style('stroke', 'grey');
          graphicContext.tooltipText = graphicContext.tooltipWrapper.append('text')
              .attr('class', 'tooltip')
              // .attr("text-anchor", "left")
              .attr('text-anchor', 'middle')
              // .attr("alignment-baseline", "middle")
              // .attr("alignment-baseline", "baseline")
              // .attr("dy", "-10px")
              .style('opacity', 1);
          graphicContext.tooltipWrapper
              // .style("visibility", "hidden");
              .style('display', 'none');
          return graphicContext;
      };
      HBoxPlotComponent.prototype.showTooltip = function (v, x, y) {
          // console.log("Show: " + v + ";" + this.constructor.name);
          // console.log('Show: ' + v + '; ' + x + ': ' + y);
          // console.log('v', SmartRounder.round(v));
          // console.log('x', this.graphicContext.xScale(x));
          // console.log('y', this.graphicContext.yScale(y));
          if (!this.graphicContext.tooltipText) {
              return;
          }
          this.graphicContext.tooltipText
              .attr('x', this.graphicContext.xScale(x))
              .attr('y', this.graphicContext.yScale(y))
              .text(SmartRounder.round(v));
          // I have to change the display here even before the box is ready as
          // in firefox the getBBox was not working if called with display none
          // giving NS_ERROR_FAILURE 2147500037
          this.graphicContext.tooltipWrapper
              // .style("visibility", "visible");
              .style('display', null);
          var bbox = this.graphicContext.tooltipText.node().getBBox();
          this.graphicContext.tooltipBox
              .attr('x', bbox.x - 3)
              .attr('y', bbox.y - 2)
              .attr('width', bbox.width + 6)
              .attr('height', bbox.height + 4);
      };
      HBoxPlotComponent.prototype.hideTooltip = function () {
          // console.log("Hide: ");
          if (!this.graphicContext.tooltipText) {
              return;
          }
          this.graphicContext.tooltipWrapper
              // .style("visibility", "hidden");
              .style('display', 'none');
          // this.graphicContext.tooltipText
          // .transition().duration(this.lookAndFeel.baseTransitionsTime / 2)
          // .style("opacity", 0);
      };
      HBoxPlotComponent.prototype.prepareScales = function (data, domain, lookAndFeel, graphicContext) {
          if (!graphicContext.xScale) {
              graphicContext.xScale = d3.scaleLinear()
                  .clamp(true);
          }
          graphicContext.xScale
              .domain(domain)
              .range([0, graphicContext.workspaceWidth]);
          if (!graphicContext.yScale) {
              graphicContext.yScale = d3.scaleBand()
                  .padding(lookAndFeel.rowGap);
          }
          var domainY = data.map(function (d) { return d.key; });
          graphicContext.yScale
              .domain(domainY)
              .range([0, graphicContext.workspaceHeight]);
          return graphicContext;
      };
      HBoxPlotComponent.prototype.plotAxisBox = function (data, domain, lookAndFeel, mainPane, graphicContext) {
          if (!graphicContext.axisWrapper) {
              graphicContext.axisWrapper = this.initAxisWrapper(mainPane);
          }
          graphicContext = this.plotHorizontalScales(domain, lookAndFeel, graphicContext);
          graphicContext = this.plotVerticalScales(data, lookAndFeel, graphicContext);
          return graphicContext;
      };
      HBoxPlotComponent.prototype.initAxisWrapper = function (mainPane) {
          var wrapper = mainPane.select('.axisWrapper');
          if (wrapper.size() === 0) {
              wrapper = mainPane.append('g').attr('class', 'axisWrapper');
              wrapper.append('g').attr('class', 'xTopAxis');
              wrapper.append('g').attr('class', 'xBottomAxis');
              wrapper.append('g').attr('class', 'yLeftAxis');
              wrapper.append('g').attr('class', 'yRightAxis');
          }
          return wrapper;
      };
      HBoxPlotComponent.prototype.plotHorizontalScales = function (domain, lookAndFeel, graphicContext) {
          if (!graphicContext.xTopAxis) {
              graphicContext.xTopAxis = d3.axisTop(graphicContext.xScale);
          }
          if (!graphicContext.xBottomAxis) {
              graphicContext.xBottomAxis = d3.axisBottom(graphicContext.xScale);
          }
          graphicContext.axisWrapper
              .select('g.xTopAxis')
              .call(graphicContext.xTopAxis);
          var elm = graphicContext.axisWrapper.select('g.xBottomAxis');
          elm = (graphicContext.transitionOn ? elm.transition(graphicContext.transition) : elm);
          elm
              .attr('transform', 'translate(0,' + graphicContext.workspaceHeight + ')')
              .call(graphicContext.xBottomAxis);
          return graphicContext;
      };
      HBoxPlotComponent.prototype.plotVerticalScales = function (data, lookAndFeel, graphicContext) {
          if (!graphicContext.yLeftAxis) {
              graphicContext.yLeftAxis = d3.axisLeft(graphicContext.yScale)
                  .tickFormat(function () { return ''; });
          }
          if (!graphicContext.yRightAxis) {
              graphicContext.yRightAxis = d3.axisRight(graphicContext.yScale)
                  .tickValues([]);
          }
          var elm = graphicContext.axisWrapper.select('g.yLeftAxis');
          elm = (graphicContext.transitionOn ? elm.transition(graphicContext.transition) : elm);
          elm
              .call(graphicContext.yLeftAxis);
          elm = graphicContext.axisWrapper.select('g.yRightAxis')
              .attr('transform', 'translate(' + graphicContext.workspaceWidth + ',0)');
          elm = (graphicContext.transitionOn ? elm.transition(graphicContext.transition) : elm);
          elm
              .call(graphicContext.yRightAxis);
          return graphicContext;
      };
      HBoxPlotComponent.prototype.plotDataBoxes = function (boxes, lookAndFeel, mainPane, graphicContext) {
          if (!graphicContext.dataWrapper) {
              graphicContext.dataWrapper = mainPane.append('g').attr('class', 'dataWrapper');
          }
          var boxWidgets = graphicContext.dataWrapper.selectAll('.boxWidget');
          boxWidgets = boxWidgets.data(boxes, function (d) { return d.key; });
          this.updateBoxWidgets(boxWidgets, lookAndFeel, graphicContext);
          var newBoxWidgets = boxWidgets.enter()
              .append('g').attr('class', 'boxWidget');
          this.createBoxWidgets(newBoxWidgets, lookAndFeel, graphicContext);
          boxWidgets.exit().remove();
          return graphicContext;
      };
      HBoxPlotComponent.prototype.updateBoxWidgets = function (boxWidgets, lookAndFeel, graphicContext) {
          // this.ngZone.runOutsideAngular(() => {
          boxWidgets.select('rect.backdrop')
              .call(this.positionBackdrop, graphicContext);
          this.updateWhiskers(boxWidgets.select('g.whiskers'), graphicContext);
          boxWidgets.select('g.box rect')
              .call(this.positionBoxRectangle, graphicContext);
          boxWidgets.select('g.box line.medianline')
              .call(this.positionMedianLine, graphicContext);
          boxWidgets.select('g.box line.meanline')
              .call(this.positionMeanLine, graphicContext);
          var out = boxWidgets.select('g.outliers').selectAll('.outlier')
              .data(function (d) { return d.outliers.map(function (x) { return [x, d.key, d.color]; }); });
          out.enter()
              .call(this.createOutlier, lookAndFeel, graphicContext, this.positionOutlier);
          out.call(this.positionOutlier, graphicContext);
          out.exit().remove();
          // });
      };
      HBoxPlotComponent.prototype.positionBackdrop = function (elm, graphicContext) {
          elm = (graphicContext.transitionOn ? elm.transition(graphicContext.transition) : elm);
          elm
              .attr('x', function (d) { return offsetScaleValue(d.lowWskr, -5, graphicContext.xScale); })
              .attr('y', function (d) {
              return graphicContext.yScale(d.key);
          })
              .attr('width', function (d) {
              var x1 = offsetScaleValue(d.lowWskr, -5, graphicContext.xScale);
              var x2 = offsetScaleValue(d.highWskr, +5, graphicContext.xScale);
              return x2 - x1;
          })
              .attr('height', function (d) {
              return graphicContext.yScale.bandwidth();
          });
      };
      HBoxPlotComponent.prototype.positionBoxRectangle = function (elm, graphicContext) {
          elm = (graphicContext.transitionOn ? elm.transition(graphicContext.transition) : elm);
          elm
              .attr('x', function (d) { return graphicContext.xScale(d.fstQnt); })
              .attr('y', function (d) {
              return graphicContext.yScale(d.key);
          })
              .attr('width', function (d) { return (graphicContext.xScale(d.thrdQnt) - graphicContext.xScale(d.fstQnt)); })
              .attr('height', function (d) {
              return graphicContext.yScale.bandwidth();
          })
              .style('stroke', function (d) { return d.color; })
              .style('fill', function (d) { return d.color; });
      };
      HBoxPlotComponent.prototype.positionMedianLine = function (elm, graphicContext) {
          elm = (graphicContext.transitionOn ? elm.transition(graphicContext.transition) : elm);
          elm
              .attr('x1', function (d, i) { return graphicContext.xScale(d.median); })
              .attr('y1', function (d, i) { return graphicContext.yScale(d.key); })
              .attr('x2', function (d, i) { return graphicContext.xScale(d.median); })
              .attr('y2', function (d, i) { return graphicContext.yScale(d.key) + graphicContext.yScale.bandwidth(); })
              .style('stroke', function (d) { return d.color; })
              // .style("visibility", d => d.mean === d.median ? "hidden" : "visible");
              .style('display', function (d) { return d.mean === d.median ? 'none' : null; });
      };
      HBoxPlotComponent.prototype.positionMeanLine = function (elm, graphicContext) {
          elm = (graphicContext.transitionOn ? elm.transition(graphicContext.transition) : elm);
          elm
              .attr('x1', function (d, i) { return graphicContext.xScale(d.mean); })
              .attr('y1', function (d, i) { return graphicContext.yScale(d.key); })
              .attr('x2', function (d, i) { return graphicContext.xScale(d.mean); })
              .attr('y2', function (d, i) { return graphicContext.yScale(d.key) + graphicContext.yScale.bandwidth(); })
              .style('stroke', function (d) { return d.color; });
      };
      HBoxPlotComponent.prototype.positionOutlier = function (elm, graphicContext) {
          elm = (graphicContext.transitionOn ? elm.transition(graphicContext.transition) : elm);
          elm.attr('cx', function (d) { return graphicContext.xScale(d[0]); })
              .attr('cy', function (d) { return graphicContext.yScale(d[1]) + graphicContext.yScale.bandwidth() / 2; })
              .style('stroke', function (d) { return d[2]; })
              .style('fill', function (d) { return d[2]; });
      };
      HBoxPlotComponent.prototype.createOutlier = function (elm, lookAndFeel, graphicContext, positionOutlierFunction) {
          elm
              .append('circle')
              .attr('class', 'outlier')
              .attr('r', lookAndFeel.outliersCircleRadius)
              .style('stroke-width', lookAndFeel.outliersStrokeWidth)
              .style('fill-opacity', lookAndFeel.outliersFillOpacity)
              .call(positionOutlierFunction, graphicContext);
      };
      HBoxPlotComponent.prototype.positionWhiskerLine = function (elm, left, graphicContext) {
          elm = (graphicContext.transitionOn ? elm.transition(graphicContext.transition) : elm);
          elm
              .attr('x1', function (d, i) { return left ? graphicContext.xScale(d.lowWskr) : graphicContext.xScale(d.thrdQnt); })
              .attr('y1', function (d, i) { return graphicContext.yScale(d.key) + graphicContext.yScale.bandwidth() / 2; })
              .attr('x2', function (d, i) { return left ? graphicContext.xScale(d.fstQnt) : graphicContext.xScale(d.highWskr); })
              .attr('y2', function (d, i) { return graphicContext.yScale(d.key) + graphicContext.yScale.bandwidth() / 2; })
              .style('stroke', function (d) { return d.color; })
              // .style("visibility", d => (left && (d.lowWskr === d.fstQnt)) || (!left && (d.highWskr === d.thrdQnt)) ? "hidden" : "visible");
              .style('display', function (d) { return (left && (d.lowWskr === d.fstQnt)) || (!left && (d.highWskr === d.thrdQnt)) ? 'none' : null; });
      };
      HBoxPlotComponent.prototype.positionWhiskerTip = function (elm, left, graphicContext) {
          elm = (graphicContext.transitionOn ? elm.transition(graphicContext.transition) : elm);
          elm
              .attr('x1', function (d, i) { return left ? graphicContext.xScale(d.lowWskr) : graphicContext.xScale(d.highWskr); })
              .attr('y1', function (d, i) { return graphicContext.yScale(d.key); })
              .attr('x2', function (d, i) { return left ? graphicContext.xScale(d.lowWskr) : graphicContext.xScale(d.highWskr); })
              .attr('y2', function (d, i) { return graphicContext.yScale(d.key) + graphicContext.yScale.bandwidth(); })
              .style('stroke', function (d) { return d.color; })
              // .style("visibility", d => (left && (d.lowWskr === d.fstQnt)) || (!left && (d.highWskr === d.thrdQnt)) ? "hidden" : "visible");
              .style('display', function (d) { return (left && (d.lowWskr === d.fstQnt)) || (!left && (d.highWskr === d.thrdQnt)) ? 'none' : null; });
      };
      HBoxPlotComponent.prototype.updateWhiskers = function (whiskers, graphicContext) {
          whiskers.select('line.whiskerlineL')
              .call(this.positionWhiskerLine, true, graphicContext);
          whiskers.select('line.whiskerlineR')
              .call(this.positionWhiskerLine, false, graphicContext);
          whiskers.select('line.whiskertipL')
              .call(this.positionWhiskerTip, true, graphicContext);
          whiskers.select('line.whiskertipR')
              .call(this.positionWhiskerTip, false, graphicContext);
      };
      HBoxPlotComponent.prototype.createWhiskers = function (whiskers, lookAndFeel, graphicContext) {
          var lwhiskr = whiskers.append('line')
              .attr('class', 'whiskerlineL')
              .style('stroke-width', lookAndFeel.whiskerStrokeWidth)
              .style('stroke-dasharray', '4 3')
              .call(this.positionWhiskerLine, true, graphicContext);
          var rwhiskr = whiskers.append('line')
              .attr('class', 'whiskerlineR')
              .style('stroke-width', lookAndFeel.whiskerStrokeWidth)
              .style('stroke-dasharray', '4 3')
              .call(this.positionWhiskerLine, false, graphicContext);
          var lTip = whiskers.append('line')
              .attr('class', 'whiskertipL')
              .style('stroke-width', lookAndFeel.whiskerStrokeWidth)
              .call(this.positionWhiskerTip, true, graphicContext);
          var rTip = whiskers.append('line')
              .attr('class', 'whiskertipR')
              .style('stroke-width', lookAndFeel.whiskerStrokeWidth)
              .call(this.positionWhiskerTip, false, graphicContext);
      };
      HBoxPlotComponent.prototype.createBoxes = function (widgets, lookAndFeel, graphicContext) {
          var rect = widgets.append('rect')
              .attr('class', 'box')
              .style('stroke-width', lookAndFeel.boxStrokeWidth)
              .style('fill-opacity', lookAndFeel.boxFillOpacity)
              .call(this.positionBoxRectangle, graphicContext);
          var median = widgets.append('line')
              .attr('class', 'medianline')
              .style('stroke-width', lookAndFeel.boxStrokeWidth)
              .call(this.positionMedianLine, graphicContext);
          var instance = this;
          this.ngZone.runOutsideAngular(function () {
              rect.on('mouseover', function (evnt, d) {
                  instance.showTooltip(d.median, d.median, d.key);
              })
                  .on('mouseout', function () {
                  instance.hideTooltip();
              });
              median.on('mouseover', function (evnt, d) {
                  instance.showTooltip(d.median, d.median, d.key);
              })
                  .on('mouseout', function () {
                  instance.hideTooltip();
              });
          });
          var mean = widgets
              .append('line')
              .attr('class', 'meanline')
              .style('stroke-width', lookAndFeel.meanStrokeWidth)
              .style('stroke-dasharray', '4 2')
              .call(this.positionMeanLine, graphicContext);
          // has to be outside angular, to prevent detection
          this.ngZone.runOutsideAngular(function () {
              mean
                  .on('mouseover', function (evnt, d) {
                  instance.showTooltip(d.mean, d.mean, d.key);
              })
                  .on('mouseout', function () {
                  instance.hideTooltip();
              });
          });
      };
      HBoxPlotComponent.prototype.createBoxWidgets = function (newBoxWidgets, lookAndFeel, graphicContext) {
          // this.ngZone.runOutsideAngular(() => {
          var instance = this;
          var backdrops = newBoxWidgets.append('rect').attr('class', 'backdrop')
              // .style("stroke-width", lookAndFeel.boxStrokeWidth)
              .style('fill-opacity', lookAndFeel.backdropOpacity)
              .style('fill', lookAndFeel.backdropColor)
              .call(this.positionBackdrop, graphicContext);
          var whiskers = newBoxWidgets.append('g').attr('class', 'whiskers');
          this.createWhiskers(whiskers, lookAndFeel, graphicContext);
          var boxes = newBoxWidgets.append('g').attr('class', 'box');
          this.createBoxes(boxes, lookAndFeel, graphicContext);
          var outliers = newBoxWidgets.append('g').attr('class', 'outliers');
          outliers.selectAll('.outlier')
              .data(function (d) { return d.outliers.map(function (x) { return [x, d.key, d.color]; }); })
              .enter()
              .call(this.createOutlier, lookAndFeel, graphicContext, this.positionOutlier);
          // });
      };
      return HBoxPlotComponent;
  }());
  HBoxPlotComponent.decorators = [
      { type: core.Component, args: [{
                  selector: 'bd2-ngx-hbox-plot',
                  changeDetection: core.ChangeDetectionStrategy.OnPush,
                  template: "\n    <div class=\"hbox-plot\" [hidden]=\"hidden\"></div>\n  ",
                  styles: ["\n      :host /deep/ .axisWrapper path {\n        stroke: gray;\n      }\n\n      :host /deep/ .axisWrapper line {\n        stroke: gray;\n      }\n\n      :host /deep/ .axisWrapper text {\n        fill: gray;\n      }\n    "]
              },] }
  ];
  HBoxPlotComponent.ctorParameters = function () { return [
      { type: core.NgZone },
      { type: core.ChangeDetectorRef },
      { type: core.ElementRef }
  ]; };
  HBoxPlotComponent.propDecorators = {
      hidden: [{ type: core.Input }],
      data: [{ type: core.Input }],
      removed: [{ type: core.Input }],
      domain: [{ type: core.Input }],
      palette: [{ type: core.Input }],
      labels: [{ type: core.Input }],
      labelsOn: [{ type: core.Input }],
      lookAndFeel: [{ type: core.Input }],
      sorted: [{ type: core.Input }],
      colors: [{ type: core.Output }]
  };

  var BD2NgxHBoxplotModule = /** @class */ (function () {
      function BD2NgxHBoxplotModule() {
      }
      return BD2NgxHBoxplotModule;
  }());
  BD2NgxHBoxplotModule.decorators = [
      { type: core.NgModule, args: [{
                  declarations: [HBoxPlotComponent],
                  imports: [],
                  exports: [HBoxPlotComponent]
              },] }
  ];

  /*
   * Public API Surface of bd2-ngx-hboxplot
   */

  /**
   * Generated bundle index. Do not edit.
   */

  exports.BD2NgxHBoxplotModule = BD2NgxHBoxplotModule;
  exports.HBoxPlotComponent = HBoxPlotComponent;

  Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=bd2-ngx-hboxplot.umd.js.map
